运行时数据区域

有一些是会随着虚拟机的启动而创建,随着虚拟机的退出而销毁.另一些于线程一一对应

虚拟机栈,本地方法栈,程序计数器,是线程私有的,方法区和堆是共享的

jvm线程:

1. 虚拟机线程
2. 周期任务线程
3. gc线程
4. 编译线程
5. 信号调度线程

![1589560944388](运行时数据区域.assets/1589560944388.png) 

程序计数器

是一个较小的内存空间,可以当作当前线程,字节码的行号指示器.字节码解释器工作是就是通过改变这个计数器的值来进行执行下一条指令,分支,循环,跳转,异常,线程恢复都是靠这个,每个线程有一个自己的计数器, 记录的是一个指令的地址,执行native 方法,值制空,

Java虚拟机栈.

每个方法执行的同时都会创建一个栈帧,用于存储局部变量表,操作数栈,动态链接,方法出口,调用到执行完,都是在虚拟机栈对应的入栈和出栈.

优点是跨平台，指令集小，编译器容易实现，

缺点性能下降，相同功能，栈需要更多的指令。

栈解决是运行时的单位，堆是存储单位。

栈是说数据如何处理，而堆是数据怎么存储，怎么放在哪放。

Java虚拟机栈内部是保存一个个的栈帧，对应着每一次Java方法调用。

生命周期 与线程一直，

作用是主要管理Java程序运行中， 保存的方法的局部变量（8中基本类型，以及引用），部分结果，并参与方法的调用和返回。

栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器

操作只有两个入栈和出栈，方法执行入栈，结束出栈。

不存在垃圾回收。

Java允许栈为动态的，或者固定的，

当是固定的时候，超过最大容量，抛出，stackoverflowerror

当是动态的时候，无法申请到内存，就会抛出outofmenoryerror

设置栈的大小 -Xss 256k

每个栈的数据都是以栈帧的格式存在。

方法对应一个栈帧，栈帧是一快内存区块，是数据集。维系各种数据。

执行引擎只支持当前栈帧，

不同的线程，不允许相互引用栈帧。

抛出异常会导致栈帧被弹出。



每个栈帧储存着：

局部变量表

局部变量数组，本地变量表

数字数组，主要存放方法参数，方法定义的局部变量。例如基本数据类型，对象的引用。

是线程私有的，不存在数据安全问题

容量编译期就确定，保存在code属性中的，maximum local variables数据项。不会改变、

基本单位是slot（变量槽） 32位以内的占一个槽，64位占两个

方法嵌套的次数由栈的大小决定，栈越大，方法嵌套越多，局部变量表只在当前方法有效，调用结束后就随着方法栈帧被销毁。

如果当前帧是由构造方法或者实例方法创建的也就是非静态方法，该对象引用this会存放在index 为0 的slot处。

局部变量的槽位是可以被重用的，如果一个变量到了作用域，过期的局部变量会被新的局部变量占据，已到达节省资源的目的。

变量的分类按照数据类型： 1， 基本数据类型，2. 引用数据类型。

类的声明位置1. 成员变量，使用前默认初始化。2.局部变量使用前必须显式赋值。

局部变量表的变量也是重要的垃圾回收根节点，只要被局部变量表直接或者间接引用的都不会被回收。







操作数栈 



解释引擎是基于 栈的执行引擎，其中栈指的是操作数栈，调用方法带有返回值的话，其方法的返回孩子会被压入栈中，并更新下一条执行字节码的指令。主要用于报存计算过程的中间结果，作为计算过程中的变量临时储存空间、

操作栈并非采用索引的方式来进行数据访问。而是用出栈入栈的方式。

栈顶元素全部被缓存在寄存器中，降低对内存的读写次数，提升执行速度。







动态链接 指向运行时常量池的方法引用。

包含运行时常量池中对该栈帧的所属方法的引用，目的是为了支持当前代码的动态链接，

源文件被编译到字节码中，所有的方法和变量都作为符号引用保存在常量池中，动态链接的作用就是为了将符号引用转换为调用方法的直接引用。

静态链接

目标方法编译器就可以知道，

动态链接被调用的方法在编译器无法被确定，只能通过符号应用转化为直接引用，这就是动态链接。

编译期已经确定下来了，这个方法叫非虚方法。

静态方法，私有方法，final方法，实例构造器 父类方法都是非虚方法。

多态的前提1. 类的继承，方法的重写。

普通调用的指令

1. invokestatic 调用静态方法 非虚
2. invokespecial 调用《init》方法私有以及父类方法  非虚
3. invokevirtual 调用所有虚方法
4. invokeinterface 调用接口方法 虚方法
5. invokedynamic 动态解析出来需要调用的方法然后执行。 虚方法





方法重写的本质是

1. 找到执行对象的实际类型
2. 找到与常量描述简单名称的符号相同的方法，进行权限校验，要是通过，就直接引用，不通过就抛异常
3. 否则就按照继承关系一直对父类进行搜索和验证
4. 始终 没找到就抛异常

为了提高性能，在类的方法区建立了一个虚方法表。

虚方法表会在类的加载链接过程中被创建并开始初始化。



方法返回地址  方法正常退出或者异常退出定义

存储是该方法的pc寄存器的值

正常退出，调用者的pc寄存器的值作为返回地址的值，即调用该方法的下一个指令地址。

异常退出，通过异常表来进行确认，栈不保存这部分信息。

区别在于通过异常完成出口退出，不会给上层调用者返回值





一些附加信息

## 面试题

栈溢出的情况？

栈的深度超过设置的最大深度，就会栈溢出

调整栈的大小就能保证不出现溢出吗？

不能，内存空间有限，栈是存放在内存中的，

给栈的分配内存越大越好吗？

不是，要按需分配，使内存使用效率最高

垃圾回收不会涉及到虚拟机栈

方法定义的局部变量是否线程安全    具体问题具体分析

如果只有一个线程才可以操作此数据，说明线程安全

如果多个线程操作数据，则数据为共享数据，不考虑同步机制，会存在线程安全问题。









本地方法栈

本地方法是一个native 方法，是一个非Java代码接口。

native可以与其他的Java标识符连用，但是abstract 除外。



虚拟机栈是为虚拟机执行Java方法(字节码)服务.本地方法,是为了使用到的native方法服务的.







































